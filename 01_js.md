<!-- 1ï¸âƒ£ What is the difference between var, let, and const? -->
 Var:- 
 var is a function-scoped variable declaration keyword introduced in ES5. It allows both re-declaration and reassignment. It is hoisted and initialized with undefined, which may lead to unexpected behavior.â€

ğŸŒ Real-Life Example:sd
Think of var like a company notice board.

If someone changes the notice, everyone in the company sees the updated message.
<!-- 
var message = "Meeting at 10 AM";

if (true) {
  var message = "Meeting Cancelled";
}

console.log(message); // Meeting Cancelled -->

Let:-
â€œlet is a block-scoped variable introduced in ES6. It allows reassignment but does not allow re-declaration in the same scope. It is hoisted but remains in the Temporal Dead Zone until initialized.â€

<!-- Real-Life Example: -->
Think of let like a classroom whiteboard.

Changes inside one classroom do not affect others.
<!-- 
let topic = "Math";

if (true) {
  let topic = "Science";
  console.log(topic); // Science
}

console.log(topic); // Math -->
ğŸ‘‰ Outside value stays the same.

Const:- 
â€œconst is a block-scoped variable introduced in ES6. It does not allow reassignment and re-declaration in the same scope. It is hoisted but remains in the Temporal Dead Zone until initialized

<!-- Real-Life Example: -->
Think of const like a government law.
Once created, it cannot be changed.
<!-- 
const country = "India";

country = "USA"; // Error -->
ğŸ‘‰ You cannot change it.
--------------------------------------------------------------------------------
<!-- ğŸ”¥ 2ï¸âƒ£ What is Hoisting? -->
Hoisting is JavaScriptâ€™s behavior of moving variable and function declarations to the top of their scope before execution.

Imagine your name is already written on the attendance list before the class starts.

Even if the teacher calls your name first,
your name is already in the list.
ğŸ‘‰ That means your name was prepared earlier.
<!-- 
console.log(a);
var a = 5; -->
Output: undefined


<!-- ğŸ”¥ 3ï¸âƒ£ Difference Between == and === -->
== â†’  compare the value
=== â†’   compare the value + type
<!-- 
5 == "5"   // true
5 === "5"  // false -->
ğŸ‘‰ Always use ===.

<!-- ğŸ”¥ 4ï¸âƒ£ What is Closure? -->
A closure is a function that remembers variables from its outer scope even after the outer function has finished execution.
Hindi:-
Closure matlab inner function ko outer function ki variables yaad rehti hain.

ğŸ”¥ Real use: Private variables, counters, data hiding.
<!-- 
function outer(){
    let count =  0;
    return function inner(){
        count++;
        console.log(count);
    };
} 

let counter = outer();
counter(); // 1
-->
<!-- Real-world Use -->
Used in:
Data privacy
Counters
Event handlers
React hooks

<!-- ğŸ”¥ 5ï¸âƒ£ What is Event Delegation? -->
In event delegation, a single event listener is attached to a parent element to handle events for its child elements.
This improves performance because we avoid attaching multiple event listeners to individual child elements

<!-- Why This Is Better? -->
Only 1 event listener
Better performance
Works for dynamically added elements

<ul id="list">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>

let list = document.getElementById("list");

list.addEventListener("click", function(event) {
  if (event.target.tagName === "LI") {
    console.log("Clicked:", event.target.textContent);
  }
});

Here I attached a single event listener to the parent <ul> element.
When a child <li> is clicked, the event bubbles up to the parent,
and using event.target, we identify which child was clicked.
<!-- --------------------------------------------------ğŸ”¥ 6ï¸âƒ£ What is Event Bubbling? -->
Event bubbling is a process in JavaScript where an event starts from the target element and propagates upward to its parent elements.
<!-- Real-World -->
Imagine there is a fire alarm in a building.
The alarm starts in one room (child element).
Then the signal spreads throughout the entire building (parent elements).
The same concept applies in event bubbling.

<div id="parent">
  <button id="child">Click Me</button>
</div>

document.getElementById("parent").addEventListener("click", function() {
  console.log("Parent Clicked");
});

document.getElementById("child").addEventListener("click", function() {
  console.log("Child Clicked");
});
<!-- O/P -->
Child Clicked
Parent Clicked

<!-- event.stopPropagation() se rok sakte hain. -->

<!-- ğŸ”¥ 7ï¸âƒ£ What is Callback Function? -->
A callback function is a function that is passed as an argument to another function and is executed after some task is completed.

<!-- Real-World Example: -->
 Online Order (Callback)
A customer places an order â†’ the payment is completed â†’ a confirmation message is sent.
The confirmation message comes after the payment is successful.
In the same way, a callback function runs after another function finishes its work
<!-- 
function greet(name) {
    console.log("Hello " + name);
}
function processUser(callback) {
    callback("Rahul");
}
processUser(greet); -->


<!-- ğŸ”¥ 8ï¸âƒ£ What is Promise? -->
A Promise in JavaScript is an object that represents the eventual completion or failure of an asynchronous operation.
It has three states: pending, fulfilled, and rejected.
We handle promises using .then(), .catch(), and .finally().

<!-- Real-life Example -->
Imagine you take an exam.
If you pass â†’ You will receive a certificate (resolve).
If you fail â†’ You will not receive a certificate (reject).
The result will come in the future â€” not immediately

âœ… Promise Syntax
<!-- 
const myPromise = new Promise((resolve, reject) => {
  let success = true;

  if (success) {
    resolve("Operation Successful");
  } else {
    reject("Operation Failed");
  } -->

ğŸ”¥ 2ï¸âƒ£ What is Promise Chaining?
Promise chaining is executing multiple asynchronous operations sequentially using multiple .then() methods.
<!-- 
Promise.resolve(10)
  .then(num => num * 2)
  .then(num => num + 5)
  .then(result => console.log(result)); -->

  